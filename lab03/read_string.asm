%include "asm_io.inc"

; ------------------------------------------------------------
; 문자열 한 줄을 직접 읽어서 버퍼에 저장하는 예제
; - 최대 31자까지만 입력받고, 마지막에는 반드시 NULL(0) 문자를 넣기
; ------------------------------------------------------------

segment .data
    msg_in      db  '문자열을 입력하세요 (최대 31자): ', 0
    msg_out     db  '입력한 문자열: ', 0

segment .bss
    ; .bss, .data
    ; 공통점: 둘 다 프로그램에서 사용할 데이터를 저장하는 세그먼트다.
    ; 차이점:
    ;   + .data : 초기값이 있는 데이터(프로그램 시작할 때 값이 정해져 있는 것)를 둔다.
    ;   + .bss  : 초기값이 정해지지 않은 데이터(프로그램 시작 시 뭘 넣을지 모르는 것)를 둔다.
    ; 우리가 지금 만들 문자열 버퍼는 프로그램 시작할 때는 어떤 문자가 들어올지 알 수가 없다. 그래서 초기값이 없는 .bss에 공간만(resb) 잡아두는 것이다.
    ;
    ; 아래 버퍼는 최대 31자 + 마지막 NULL 문자로 총 32바이트를 잡는다.
    string      resb    32          ; 입력 문자들을 저장할 버퍼 (초기값 없음)

segment .text
    global  main

main:
    enter   0, 0
    pusha

    ; 1. 안내 메시지 '문자열을 입력하세요 (최대 31자): ' 출력
    mov     eax, msg_in
    call    print_string

    ; edx는 "지금까지 저장한 문자 개수"를 세는 용도로 사용
    ; 시작할 때는 당연히 0개 입력했으니 0으로 초기화해주기
    mov     edx, 0

; ------------------------------------------------------------
; 2. 문자 입력 루프
;    - 한 글자씩 read_char로 읽는다.
;    - 읽은 문자는 일단 버퍼에 넣는다. (엔터도 포함해서!)
;    - 그런 다음 개수(edx)를 1 증가시킨다.
;    - 그리고 그 문자가 엔터였는지 확인해서, 엔터면 종료한다.
; ------------------------------------------------------------
repeat:
    call    read_char       ; 사용자로부터 문자 1개 입력받기

    ; 2-1. 일단 입력한 문자를 버퍼에 저장 (엔터(0x0A)도 포함해서 넣기)
    ;      string + edx 위치에 저장
    mov     [string + edx], al

    ; 2-2. 문자 1개를 저장했으니 현재까지 입력된 문자 개수를 1 증가
    inc     edx

    ; 2-3. 방금 입력한 문자가 엔터(줄바꿈, 0x0A)인지 확인
    ;      주의: 우리는 엔터도 버퍼에 넣어버렸기 때문에,
    ;            나중에 그 엔터 자리를 NULL(0)로 덮어쓸 것이다.
    cmp     al, 0x0A        ; 엔터인지 확인!
    je      input_done      ; 엔터면 입력 종료로 이동

    ; 2-4. 아직 엔터는 아니고, 계속 입력하려고 하는데 버퍼 크기(31자)를 넘었는지 확인!!
    ;      여기서는 31자까지만 유효 데이터로 보고, 32번째는 NULL 자리로 남겨두기
    cmp     edx, 31         ; 지금까지 저장한 글자가 31개 이상인지 확인!
    jl      repeat          ; 31개 미만이면 계속 더 받아도 되니까 repeat으로 이동!

    ; --------------------------------------------------------
    ; 여기까지 왔다는 것은
    ; 엔터는 아직 안 들어오고, 버퍼는 이미 꽉 찬 상황! (31자 다 썼음)
    ; 그러면 남아 있는 입력을 엔터가 나올 때까지 그냥 버리기!!!
    ; --------------------------------------------------------
    
    ; edx=31 상태에서 flush_rest로 가게 됨
    ; input_done에서 dec edx를 하면 edx=30이 되어
    ; string[30]을 NULL로 덮어쓰게 되는 문제가 있음!
    ; 따라서 여기서 edx를 1 증가시켜서 32로 만들어둠
    ; 그러면 input_done에서 dec 후 edx=31이 되어
    ; string[31]에 NULL이 들어가게 됨 (정확한 위치!)
    inc     edx             ; edx를 32로 만들기 (31 → 32)
    
flush_rest:                 ; 버퍼가 꽉 찬 뒤, 사용자가 계속 입력하는 나머지 글자들을 무시하고 엔터(줄바꿈)까지 싹 버리는 역할
    call    read_char
    cmp     al, 0x0A        ; 방금 읽은 문자가 엔터(줄바꿈, 0x0A)인지 확인!
    jne     flush_rest      ; 만약 방금 읽은 문자가 엔터가 아니라면 flush_rest로 가서 또 읽기!
    jmp     input_done      ; 엔터를 만나면 입력 끝 처리로 이동

; ------------------------------------------------------------
; 3. 입력 종료 처리
;    - "마지막으로 저장된 문자 위치"를 NULL(0)로 덮어쓰기
; ------------------------------------------------------------
input_done:
    ; 현재 edx는 "마지막으로 저장한 문자의 다음 위치"를 가리킴
    ; (왜냐면 위에서 mov 후에 inc edx 했으니까)
    ; 따라서 edx를 1 감소시켜야 "마지막 문자 위치"가 됨
    ; 
    ; 두 가지 경우:
    ; 1) 31자 이하 + 엔터: edx-1 위치에 엔터(0x0A)가 있음 → 이걸 NULL로 교체
    ; 2) 31자 초과: 위에서 inc edx 했으므로 edx=32 → dec 후 edx=31 → string[31]에 NULL
    dec     edx                     ; edx를 1 감소 (마지막 저장 위치로 이동)
    mov     byte [string + edx], 0  ; 그 위치를 NULL(0)로 덮어쓰기

    ; --------------------------------------------------------
    ; 4. "입력한 문자열:" 출력
    ; --------------------------------------------------------
    mov     eax, msg_out
    call    print_string

    ; --------------------------------------------------------
    ; 5. 우리가 버퍼에 저장해 둔 문자열 출력
    ;    위에서 마지막을 NULL(0)로 만들어두었으므로
    ;    print_string으로 안전하게 출력 가능
    ; --------------------------------------------------------
    mov     eax, string
    call    print_string
    call    print_nl

    popa
    mov     eax, 0
    leave
    ret

; 동작 원리:
    ; - repeat 루프에서 문자를 저장할 때마다 edx를 1 증가시킴
    ; - input_done에 도착했을 때 edx는 "마지막 문자 + 1" 위치를 가리킴
    ; - dec edx로 "마지막 문자" 위치로 되돌림
    ; - 그 위치에 NULL을 넣어서 문자열 종료
    ;
    ; 예시:
    ;
    ; 1) "hi" 입력 시 (2글자 + 엔터):
    ;    - string[0] = 'h', edx=1
    ;    - string[1] = 'i', edx=2
    ;    - string[2] = 0x0A (엔터), edx=3
    ;    - je input_done으로 점프
    ;    - input_done에서 dec edx → edx=2
    ;    - string[2] = 0 (엔터를 NULL로 교체)
    ;    - 출력: "hi" (2글자 + NULL)
    ;
    ; 2) "ABCDEFGHIJKLMNOPQRSTUVWXYZ12345XYZ[엔터]" 입력 시 (31자 초과):
    ;    - string[0~29]에 처음 30글자 저장
    ;    - string[30] = '5' (31번째 글자), edx=31
    ;    - cmp edx, 31 체크 → jl repeat 실패 (31 >= 31이므로)
    ;    - inc edx 실행 → edx=32 (중요!)
    ;    - flush_rest로 진입하여 'XYZ[엔터]'를 모두 버림
    ;    - input_done에서 dec edx → edx=31
    ;    - string[31] = 0 (NULL 추가)
    ;    - 출력: "ABCDEFGHIJKLMNOPQRSTUVWXYZ12345" (정확히 31글자 + NULL)
    ;
    ; 3) "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234[엔터]" 입력 시 (정확히 31글자):
    ;    - string[0~29]에 처음 30글자 저장
    ;    - string[30] = '4' (31번째 글자), edx=31
    ;    - cmp al, 0x0A → '4'는 엔터가 아님
    ;    - cmp edx, 31 체크 → jl repeat 실패 (31 >= 31이므로)
    ;    - inc edx 실행 → edx=32
    ;    - flush_rest로 진입
    ;    - read_char로 엔터 읽음 → 엔터 발견!
    ;    - jmp input_done으로 점프
    ;    - input_done에서 dec edx → edx=31
    ;    - string[31] = 0 (NULL 추가)
    ;    - 출력: "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234" (정확히 31글자 + NULL)
